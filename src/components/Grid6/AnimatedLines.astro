---
type Props = {
  lines: number;
  delayStep: number; // Np. 0.2s dla wyraźniejszych przerw
  direction: 'up' | 'down';
};

const { lines, delayStep, direction } = Astro.props;
---

{
  Array.from({ length: lines }).map((_, index) => {
    const middlePoint = (lines - 1) / 2;
    const distanceFromMiddle = Math.abs(index - middlePoint);

    // ULEPSZENIE: Bardziej liniowy staggering, ale z większym krokiem
    const animationDelayValue = (distanceFromMiddle * delayStep).toFixed(3); // Bez potęgowania, aby przerwy były równe
    const animationDelay = `${animationDelayValue}s`;

    return (
      <div
        class="lines sharp-growth"
        style={{ animationDelay }}
        class:list={{
          'left-edge': index === 0,
          'right-edge': index === lines - 1,
          'lines-up': direction === 'up',
          'lines-down': direction === 'down',
        }}
      />
    );
  })
}

<style>
  .lines { /* Wspólne style */
    opacity: 0; /* Initial state, will be animated */
    border-right: 1px solid var(--grid-overlay-color, rgba(200, 200, 255, 0.7));
    border-left: 1px solid var(--grid-overlay-color, rgba(200, 200, 255, 0.7));
  }

  .left-edge {
    border-left: unset;
  }

  .right-edge {
    border-right: unset;
  }

  .sharp-growth.lines-down {
    transform-origin: top;
    /* ULEPSZENIE: Płynniejsza i bardziej elegancka animacja z dłuższym czasem trwania i łagodniejszym easingiem */
    animation: sharp-appear 1s cubic-bezier(0.645, 0.045, 0.355, 1) forwards;
  }

  .sharp-growth.lines-up {
    transform-origin: bottom;
    /* ULEPSZENIE: Płynniejsza i bardziej elegancka animacja z dłuższym czasem trwania i łagodniejszym easingiem */
    animation: sharp-appear 1s cubic-bezier(0.645, 0.045, 0.355, 1) forwards;
  }

  /* Dla płynnego, eleganckiego wzrostu */
  @keyframes sharp-appear {
    0% {
      transform: scaleY(0);
      opacity: 0;
    }
    /* Usunięto pośrednią klatkę kluczową 50% dla opacity, aby było płynniejsze */
    100% {
      transform: scaleY(1);
      opacity: 1;
    }
  }

  /* Alternatywa dla bardziej "skokowego" wzrostu (jeśli użyjesz steps() w animacji) */
  /*
  @keyframes sharp-appear-steps {
    0% {
      transform: scaleY(0);
      opacity: 0;
    }
    33% {
        transform: scaleY(0.33);
        opacity: 1;
    }
    66% {
        transform: scaleY(0.66);
        opacity: 1;
    }
    100% {
      transform: scaleY(1);
      opacity: 1;
    }
  }
  */
  /* UWAGA: Lepszym sposobem na "steps" z clip-path (jak w poprzedniej myśli) */
  /* Jeśli chcemy "steps" z `scaleY`, powyższy przykład jest OK, ale `clip-path` może dać lepszy efekt wizualny */
  /* Dla `scaleY` i `steps()`, `opacity` trzeba by ustawić na 1 od początku trwania animacji. */
  /* Modyfikacja dla steps() z opacity: */
  @keyframes sharp-appear-steps { /* Użyj z `animation: sharp-appear-steps 0.7s steps(3, end) forwards; opacity: 1;` */
    from { transform: scaleY(0); }
    to { transform: scaleY(1); }
  }
  /* A wtedy w .sharp-growth: animation: ...; opacity: 1; */
  /* Ale to sprawi, że linie "migną" zanim animacja ruszy. Lepsze jest kontrolowanie opacity w klatkach. */
  /* Dla `steps()` często lepiej jest animować `clip-path` lub użyć go w połączeniu. */
  /* Jeśli jednak chcesz prosty `scaleY` z `steps()`: */
  /*
  .sharp-growth.lines-down {
    transform-origin: top;
    animation: scale-steps 0.7s steps(4, end) forwards;
    opacity: 1; // Linia jest od razu widoczna (ale ma 0 wysokości)
  }
  .sharp-growth.lines-up {
    transform-origin: bottom;
    animation: scale-steps 0.7s steps(4, end) forwards;
    opacity: 1;
  }
  @keyframes scale-steps {
    from { transform: scaleY(0); }
    to   { transform: scaleY(1); }
  }
  */
  /* Pamiętaj, że `steps()` ignoruje pośrednie wartości klatki kluczowej i przeskakuje. */
</style>